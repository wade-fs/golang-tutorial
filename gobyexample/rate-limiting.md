# [Go by Example](../gobyexample.md): Rate Limiting

*Rate Limiting*(限速)是控制資源利用率和保持服務質量的重要機制。 Go可以通過 [goroutine](goroutines.md)、[通道](channels.md) 和 [計時器](tickers.md)來優雅地支持速率限制。

``` go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 首先，我們來看一下基本速率限制。 
    // 假設我們要限制對傳入請求的處理。 
    // 我們將通過相同名稱的渠道提供這些請求。
    requests := make(chan int, 15)
    for i := 1; i <= 15; i++ {
        requests <- i
    }
    close(requests)

    // limiter 通道將每1000毫秒接收一個值。
    // 這是我們的限速方案中的調節器。用來讓系統每1000毫秒做一次要求
    limiter := time.Tick(1000 * time.Millisecond)

    // 通過在處理每個請求之前阻止來自限制器通道的接收，
    // 我們將自己限制為每10000毫秒1個請求。
    for req := range requests {
        <-limiter
        fmt.Println("request", req, time.Now())
    }

    // 我們可能希望在速率限制方案中允許短暫的請求突發(burst)，
    // 同時保留總體速率限制。也就是總體時間一致
    // 我們可以通過緩衝限制器通道來完成此任務。
    // 這個burstyLimiter通道最多允許突發5個事件。
    burstyLimiter := make(chan time.Time, 5)

    // 底下發出5個突發事件
    // 可以在執行時看到的時間幾乎一樣
    for i := 0; i < 5; i++ {
        burstyLimiter <- time.Now()
    }

    // 每1000毫秒發出一個突發事件
    // 前面會有5個幾乎同時的突發事件, 後續則可以另訂
    go func() {
        for t := range time.Tick(1000 * time.Millisecond) {
            burstyLimiter <- t
        }
    }()

    // 這邊模擬總共10個突發事件
    // 前5個已同時發出，剩下的是1000毫秒一次
    burstyRequests := make(chan int, 10)
    for i := 1; i <= 10; i++ {
        burstyRequests <- i
    }
    close(burstyRequests)
    for req := range burstyRequests {
        <-burstyLimiter
        fmt.Println("request", req, time.Now())
    }
}
```
[執行](http://play.golang.org/p/20c_m1AtOEI)

``` shell
$ go run rate-limiting.go
[ 1 2020-09-03 21:14:22.547035299 +0800 CST m=+1.000166516 ]
[ 2 2020-09-03 21:14:23.547125451 +0800 CST m=+2.000256690 ]
[ 3 2020-09-03 21:14:24.54712394 +0800 CST m=+3.000255188 ]
[ 4 2020-09-03 21:14:25.547124 +0800 CST m=+4.000255237 ]
[ 5 2020-09-03 21:14:26.547119387 +0800 CST m=+5.000250593 ]
[ 6 2020-09-03 21:14:27.547119484 +0800 CST m=+6.000250728 ]
[ 7 2020-09-03 21:14:28.547124788 +0800 CST m=+7.000256006 ]
[ 8 2020-09-03 21:14:29.547119058 +0800 CST m=+8.000250295 ]
[ 9 2020-09-03 21:14:30.547114648 +0800 CST m=+9.000245892 ]
[ 10 2020-09-03 21:14:31.547120278 +0800 CST m=+10.000251525 ]
[ 11 2020-09-03 21:14:32.547121159 +0800 CST m=+11.000252403 ]
[ 12 2020-09-03 21:14:33.547119564 +0800 CST m=+12.000250806 ]
[ 13 2020-09-03 21:14:34.547120506 +0800 CST m=+13.000251730 ]
[ 14 2020-09-03 21:14:35.547119217 +0800 CST m=+14.000250459 ]
[ 15 2020-09-03 21:14:36.547127447 +0800 CST m=+15.000258664 ]
request 1 2020-09-03 21:14:36.547215421 +0800 CST m=+15.000346581
request 2 2020-09-03 21:14:36.547234055 +0800 CST m=+15.000365231
request 3 2020-09-03 21:14:36.547247376 +0800 CST m=+15.000378541
request 4 2020-09-03 21:14:36.547258728 +0800 CST m=+15.000389893
request 5 2020-09-03 21:14:36.547270088 +0800 CST m=+15.000401256
request 6 2020-09-03 21:14:37.54743905 +0800 CST m=+16.000570250
request 7 2020-09-03 21:14:38.547443013 +0800 CST m=+17.000574227
request 8 2020-09-03 21:14:39.547448808 +0800 CST m=+18.000580040
request 9 2020-09-03 21:14:40.547400837 +0800 CST m=+19.000532057
request 10 2020-09-03 21:14:41.547445272 +0800 CST m=+20.000576491
```

前面15個被限速，每1000毫秒一次  
至於後面10個，有5個幾乎同時，後面5個一樣被限速

下一範例: [Atomic Counters](atomic-counters.md)
